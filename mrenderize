#!/usr/bin/env ruby
# Ruby script for interfacing with mrender to produce volumetric
# visualizations

require 'optparse'
require 'open3'

require 'rubygems'
require 'progressbar'

mrender_bin = 'mrender'
filenames = []
@options = {
  :angle_range => (0..359),
  :angle_interval => 1,
  :output_resolution => [320, 240],
  :show_frame_progress => false,
  :query => 'val', # 'gmag',
  # v gv gm gn np h l hf heval heval0 heval1 heval2 hevec hevec0 hevec1 hevec2 2d gt k1 k2 tc st si mc gc cdir1 cdir2 fc med
  :measure => 'variance'
  # max
}

OptionParser.new do |opts|
  opts.summary_width = 28
  opts.banner = "Usage: #{File.basename(__FILE__)} [options] filename.nrrd"

  def opts.show_usage
    puts self
    exit
  end

  opts.on("--angles angle1,angle2", Array, 
          "Beginning and end angles for rendering (0,359)") do |angles|
    @options[:angle_range] = Range.new(angles[0],angles[1])
  end

  opts.on("-I INTERVAL","--interval=INTERVAL",
          "Interval at which to create projections") do |interval|
    @options[:angle_interval] = interval.to_i
  end

  opts.show_usage if ARGV.empty?

  begin
    opts.order(ARGV) do |filename|
      filenames << filename
    end
  rescue OptionParser::ParseError => e
    opts.warn e.message
    opts.show_usage
  end
end

def execute_mrender(command, max)
  if @options[:show_frame_progress]
    puts "\n"
    bar = ProgressBar.new("mrender", max)
  end
  Open3.popen3(command) do |stdin, stdout, stderr|
    if @options[:show_frame_progress]
      stderr.each(" ") do |element|
        if element =~ /(\d+)\/#{max.to_s}/
          bar.set($1.to_i)
        end
      end
    else
      stderr.readlines
    end
  end
  bar.finish unless !@options[:show_frame_progress]
end

output_files = []
render_bar = ProgressBar.new("volume render", @options[:angle_range].end + 1)
render_bar.set(0)
render_bar.show_progress

# @options parsed, run rendering
filename = filenames[0]
@options[:angle_range].step(@options[:angle_interval]) do |angle|
  mrender_string = "#{mrender_bin} -i #{filenames[0]}"
  mrender_string += " -turn #{angle}"
  mrender_string += " -is #{@options[:output_resolution].join(' ')}"
  mrender_string += " -k scalar"
  mrender_string += " -q #{@options[:query]}"
  mrender_string += " -m #{@options[:measure]}"
  # copied in for now
  mrender_string += " -fr -0.1 0 4.1"
  mrender_string += " -dn -1"
  mrender_string += " -di 0"
  mrender_string += " -df 1"
  mrender_string += " -up 0 -1 0"
  mrender_string += " -rh"
  mrender_string += " -ar"
  mrender_string += " -ur -1 1"
  mrender_string += " -vr -1 1"
  mrender_string += " -step 0.0008"
  mrender_string += " -nt 16"
  mrender_string += " -k00 cubic:1,0"
  mrender_string += " -k11 cubicd:1,0"
  
  output_file = File.basename(filename, '.nrrd') +
                sprintf("-%s-%s-%03d.nrrd",
                  @options[:query], @options[:measure], angle)
  
  mrender_string += " -o #{output_file}"
  
  # puts angle.to_s + ": " + mrender_string
  # Open3.popen3(mrender_string) { |stdin, stdout, stderr| stderr.readlines }
  execute_mrender(mrender_string, @options[:output_resolution][1])
  
  output_files << output_file
  render_bar.set(angle + 1)
end
render_bar.finish
